## 책임 연쇄 패턴

<img src="https://refactoring.guru/images/patterns/content/chain-of-responsibility/chain-of-responsibility.png?id=56c10d0dc712546cc283cfb3fb463458" alt="책임 사슬 디자인 패턴" style="zoom:150%;" />

**책임 연쇄 패턴**은 일련의 핸들러를 따라 요청을 전달할 수 있는 행동 디자인 패턴입니다. 요청을 받으면 각 핸들러는 요청을 처리할지 아니면 체인의 다음 핸들러로 전달할지 결정합니다.



### 문제

온라인 주문 시스템에서 작업하고 있다고 상상해봅시다. 인증된 사용자만 주문을 생성할 수 있도록 시스템에 대한 액세스를 제한하려고 합니다. 또한 관리 권한이 있는 사용자는 모든 주문에 대한 전체 액세스 권한이 있어야 합니다.

약간의 계획 후에 이러한 검사를 **순차적으로 수행**해야 한다는 것을 깨달았습니다. 애플리케이션은 사용자의 자격 증명이 포함된 요청을 수신할 때마다 시스템에 대해 사용자 인증을 시도할 수 있습니다. 그러나 이러한 **자격 증명이 올바르지 않고 인증에 실패하면 다른 검사를 진행할 이유가 없습니다.**

![Chain of Responsibility로 문제 해결](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/problem1-en.png?id=dde084d408d2b14d632ba82583d16612)

***요청은 주문 시스템 자체에서 처리할 수 있기 전에 일련의 검사를 통과해야 합니다.***

몇 달 동안 이러한 순차 검사 중 몇 가지를 더 구현했습니다.

- 동료 중 한 명이 원시 데이터를 주문 시스템에 직접 전달하는 것은 안전하지 않다고 제안했습니다. 따라서 요청의 데이터를 삭제하기 위해 **추가 유효성 검사 단계를 추가**했습니다.
- 나중에 누군가는 시스템이 무차별 암호 해독에 취약하다는 것을 알아차렸습니다. 이를 무효화하기 위해 **동일한 IP 주소에서 오는 반복적인 실패한 요청을 필터링하는 검사를 즉시 추가**했습니다.
- 다른 누군가는 동일한 데이터가 포함된 반복 요청에 대해 캐시된 결과를 반환하여 시스템 속도를 높일 수 있다고 제안했습니다. 따라서 **적절한 캐시 응답이 없는 경우에만 요청이 시스템으로 전달되도록 하는 또 다른 검사를 추가**했습니다.

![매번 새로운 검사를 할 때마다 코드가 더 커지고 더 복잡해지고 추악해졌습니다.](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/problem2-en.png?id=88c684d3eab7707bee7b1550a2d8ae04)

***코드가 커질수록 더 복잡해졌습니다.***

이미 엉망인 것처럼 보였던 검사 코드는 새로운 기능을 추가할 때마다 점점 더 부풀려져갑니다. 하나의 검사를 변경하면 때때로 다른 검사에 영향을 줍니다. 최악의 경우 시스템의 다른 구성 요소를 보호하기 위해 검사를 재사용하려고 할 때 해당 구성 요소에 일부 검사가 필요하지만 전부는 아니기 때문에 일부 코드를 복제해야 했습니다.

이 시스템은 이해하기가 매우 어렵고 유지 관리 비용이 많이 듭니다. 당신은 어느 날 전체를 리팩토링하기로 결정할 때까지 한동안 코드와 씨름했습니다.



### 해결

다른 많은 행동 디자인 패턴과 마찬가지로, **책임연쇄 패턴은 특정 행동을 `Handler` 라고 하는 독립형 객체로 변환**합니다. 위 예의 경우 각 검사는 검사를 수행하는 단일 메서드를 사용하여 자체 클래스로 추출되어야 합니다. 요청은 데이터와 함께 이 메서드에 파라미터로 전달됩니다.

이 패턴은 이러한 핸들러를 체인으로 연결하도록 제안합니다. **연결된 각 핸들러에는 체인의 다음 핸들러에 대한 참조를 저장**하기 위한 필드가 있습니다. 요청을 처리하는 것 외에도 핸들러는 체인을 따라 요청을 더 전달합니다. 요청은 모든 핸들러가 처리할 기회를 가질 때까지 체인을 따라 이동합니다.

![핸들러가 하나씩 줄을 서서 체인을 형성합니다.](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/solution1-en.png?id=dccad3e628bd2b8f1856c99369ca6e5b)

***핸들러가 하나씩 줄 지어 체인을 형성합니다.***

가장 좋은 부분은 다음과 같습니다. **핸들러는 요청을 더 이상 체인 아래로 전달하지 않고 추가 처리를 효과적으로 중지할 수 있습니다.**

순서 지정 시스템이 있는 예제에서 핸들러는 처리를 수행한 다음 요청을 체인 아래로 더 전달할지 여부를 결정합니다. 요청에 올바른 데이터가 포함되어 있다고 가정하면 인증 확인이든 캐싱이든 모든 처리기가 기본 동작을 실행할 수 있습니다.

그러나 요청을 받으면 처리기가 처리할 수 있는지 여부를 결정하는 약간 다른 접근 방식이 있습니다 (좀 더 표준적이라고 함). 가능한 경우 더 이상 요청을 전달하지 않습니다. **따라서 요청을 처리하는 핸들러는 하나뿐이거나 전혀 처리하지 않습니다.** 이 접근 방식은 그래픽 사용자 인터페이스 내에서 요소 스택의 이벤트를 처리할 때 매우 일반적입니다.

예를 들어, 사용자가 버튼을 클릭하면 이벤트는 버튼으로 시작하여 해당 컨테이너(예: 양식 또는 패널)를 따라 이동하고 메인 애플리케이션 창으로 끝나는 GUI 요소 체인을 통해 전파됩니다. 이벤트는 처리할 수 있는 체인의 첫 번째 요소에 의해 처리됩니다. 이 예는 체인이 항상 개체 트리에서 추출될 수 있음을 보여주기 때문에 주목할 만합니다.

![개체 트리의 가지에서 체인을 형성할 수 있습니다.](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/solution2-en.png?id=cc5bab096e1b37105e1027c43a92cc8a)

***체인은 개체 트리의 가지에서 형성될 수 있습니다.***

**모든 핸들러 클래스가 동일한 인터페이스를 구현하는 것이 중요**합니다. 각 핸들러는 `execute` 메소드가 있는 다음 핸들러에만 신경을 써야 합니다 . 이렇게 하면 코드를 구체적인 클래스에 연결하지 않고도 다양한 핸들러를 사용하여 런타임에 체인을 구성할 수 있습니다.



### 구조

![Chain Of Responsibility 디자인 패턴의 구조](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/structure.png?id=848f0fc8dca57a44974d63f8181f5406)

1. `Handler`는 모든 구체적인 핸들러에 **공통적인 인터페이스를 선언**합니다.

2. `BaseHandler`는 모든 핸들러 클래스에 공통적인 상용 코드를 넣을 수 있는 선택적 클래스입니다.

   일반적으로 이 클래스는 다음 핸들러에 대한 참조를 저장하기 위한 필드를 정의합니다. 클라이언트는 핸들러를 이전 핸들러의 생성자 또는 설정자에 전달하여 체인을 구축할 수 있습니다. 클래스는 기본 처리 동작을 구현할 수도 있습니다. 즉, 존재 여부를 확인한 후 다음 처리기로 실행을 전달할 수 있습니다.

3. `ConcreateHandlers`에는 **요청을 처리하기 위한 실제 코드**가 포함되어 있습니다. 요청을 수신하면 각 핸들러는 **요청을 처리할지 여부와 함께 체인을 따라 전달할지 여부를 결정**해야 합니다.

   핸들러는 일반적으로 자체 포함되고 변경할 수 없으며 생성자를 통해 **필요한 모든 데이터를 한 번만 수락**합니다.

4. `Client`는 응용 프로그램의 논리에 따라 체인을 한 번만 구성하거나 동적으로 구성할 수 있습니다. 요청은 체인의 모든 핸들러로 보낼 수 있습니다. 첫 번째 핸들러일 필요는 없습니다.